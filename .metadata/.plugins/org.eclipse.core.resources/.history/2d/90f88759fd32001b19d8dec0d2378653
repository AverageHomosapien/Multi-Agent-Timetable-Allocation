package timetable;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import jade.content.Concept;
import jade.content.ContentElement;
import jade.content.lang.Codec;
import jade.content.lang.Codec.CodecException;
import jade.content.lang.sl.SLCodec;
import jade.content.onto.Ontology;
import jade.content.onto.OntologyException;
import jade.content.onto.basic.Action;
import jade.core.AID;
import jade.core.Agent;
import jade.core.behaviours.Behaviour;
import jade.core.behaviours.CyclicBehaviour;
import jade.core.behaviours.OneShotBehaviour;
import jade.core.behaviours.SequentialBehaviour;
import jade.core.behaviours.TickerBehaviour;
import jade.domain.DFService;
import jade.domain.FIPAException;
import jade.domain.FIPAAgentManagement.DFAgentDescription;
import jade.domain.FIPAAgentManagement.ServiceDescription;
import jade.lang.acl.ACLMessage;
import jade.lang.acl.MessageTemplate;
import timetable_ontology.TimetableOntology;
import timetable_ontology.elements.MessageBoard;
import timetable_ontology.elements.PleasedWith;
import timetable_ontology.elements.SlotsAvailable;
import timetable_ontology.elements.SlotsRequested;
import timetable_ontology.elements.SwapFinal;
import timetable_ontology.elements.SwapInitial;
import timetable_ontology.elements.Timeslot;
import timetable_ontology.elements.TutorialGroup;
import timetable_ontology.elements.UnhappySlot;

// Student Agent
public class STUDENTAGENTCOPY extends Agent{
	private Codec codec = new SLCodec();
	private Ontology ontology = TimetableOntology.getInstance();
	private AID timetableAgent;
	
	private int[][] SlotPreferences;
	private TutorialGroup[] CurrentTutorials;

	//private double scoreThreshold = 3; // BE TASK SPECIFIC -- EVEN IF DECREASING?-------
	//private int totalFitness = 0;
	
	@Override
	protected void setup() {
		register();
		getContentManager().registerLanguage(codec);
		getContentManager().registerOntology(ontology);
		
		Object[] arguments = getArguments();
		SlotPreferences = (int[][]) arguments[0];
		CurrentTutorials = (TutorialGroup[]) arguments[1];
		
		addBehaviour(new FindTimetablerBehaviour());
		addBehaviour(new AwaitCallBehaviour()); // Will be called in order by TimetablingAgent until StudentAgent is 'Happy'
		//addBehaviour(new ExamineSwapRequestBehaviour());
	}
	
	// Finds the Student Agents and adds them to the UnhappyAgents list
	public class FindTimetablerBehaviour extends OneShotBehaviour {
		
		@Override
		public void action() {
			DFAgentDescription timetablerTemplate = new DFAgentDescription();
			ServiceDescription sd = new ServiceDescription();
			sd.setType("timetabling-agent");
			timetablerTemplate.addServices(sd);
			try{
				DFAgentDescription[] ttAgent  = DFService.search(myAgent,timetablerTemplate); 
				timetableAgent = ttAgent[0].getName();
			}
			catch(FIPAException e) {
				e.printStackTrace();
			}
		}
	}
	
	// Awaiting call of the timetable agent to begin
	public class AwaitCallBehaviour extends CyclicBehaviour { // PROCESSING OF THIS FUNCTION NEEDS SPLIT

		@Override
		public void action() {
			//ACLMessage msg = myAgent.receive(MessageTemplate.and(MessageTemplate.MatchConversationId("messageBoard"), MessageTemplate.MatchPerformative(ACLMessage.INFORM))); 
			ACLMessage msg = myAgent.receive(MessageTemplate.MatchConversationId("messageBoard"));
			if (msg != null) {
				try {
					System.out.println(getAID().getLocalName() + " has received message " + msg.getContent()); //print out the message content in SL
					ContentElement ce = getContentManager().extractContent(msg);
					
					if (ce instanceof SlotsAvailable) {
						SlotsAvailable available = (SlotsAvailable) ce;
						MessageBoard mb = available.getBoard();
						List<SwapInitial> messageBoard = mb.getMessageBoard();
						
						System.out.println("Messageboard size is " + messageBoard.size());
						
						// Checking if messages in the messageboard -- otherwise just send unwanted slots
						if (messageBoard.size() > 0) {
							System.out.println("CurrentTutorial ID is " + CurrentTutorials[0].getTutorialID());
							
							// Jagged array to hold slots we're interested in- for each tutorial group  ----------- FIND MOST INTERESTED SLOTS? SENDING MULTIPLE MESSAGES MAY BE TOUGH
							ArrayList<SwapInitial>[] interestedSlots = new ArrayList[CurrentTutorials.length];
							for (int i = 0; i < CurrentTutorials.length; i++) {
								interestedSlots[i] = new ArrayList<SwapInitial>();
							}
							
							System.out.println("FILLING INTERESTED SLOTS");
							// Fill the 'interested slots'
							for (int i = 0; i < CurrentTutorials.length; i++) {
								for (SwapInitial it : messageBoard) {
									// If matching tutorial class
									if (!it.getAgentFrom().equals(getAID())) { // If not posted by this agent
										if (it.getTutorial().getTutorialID().equals(CurrentTutorials[i].getTutorialID())) {
											System.out.println("FOUND BETTER SLOT");
											// If better than current slot
											if (SlotFitness(it.getTutorial().getTimeslot()) > SlotFitness(CurrentTutorials[i].getTimeslot())) {
												System.out.println("FOUND BETTER SLOT FITNESS");
												interestedSlots[i].add(it);
												System.out.println("Agent: " + myAgent.getAID().getLocalName() + " adding interested slot:- " + it.getTutorial().getTimeslot().getDay() +" "+
														it.getTutorial().getTimeslot().getTime());
											}
										}
									}
								}
							}
							
							// Agents that have confirmed they wish to swap slots
							ArrayList<SwapFinal> slotsToSwitch = new ArrayList<SwapFinal>();
							
							System.out.println("interested slots ARRAY size is " + interestedSlots[0].size());
							
							
							// FINISH AFTER SENDING SWAPCONFIRM SLOTS
							
							// Find which agents will swap slots
							for (int i = 0; i < interestedSlots.length; i++) {
								TutorialGroup groupTo = null;
								
								System.out.println("INTERESTED SLOTS I (0) is: " + interestedSlots[0].get(0));
								
								
								// Null pointer if checking through 
								if (interestedSlots[i].size() > 0) {
									for (TutorialGroup tut : CurrentTutorials) { // Find which tutorial group matches
										if (tut.getTutorialID() == interestedSlots[i].get(0).getTutorial().getTutorialID()) {
											groupTo = tut;
											break;
										}
									}
									
									for (SwapInitial swap : interestedSlots[i]) {
										System.out.println("INSIDE THIS BLOODY INTERESTED SLOT FUNCTION WITH SWAP DAY " + swap.getTutorial().getTimeslot().getDay() 
												+ " AND SWAP TIME " + swap.getTutorial().getTimeslot().getTime());
										SwapFinal swapRequest = new SwapFinal();
										swapRequest.setInitalSwapRequest(swap);
										swapRequest.setAgentTo(myAgent.getAID());
										swapRequest.setTutorialTo(groupTo);
										
										SequentialBehaviour requestActivity = new SequentialBehaviour();
										requestActivity.addSubBehaviour(new InitiateSwapRequestBehaviour(swapRequest)); // Requests the swap
										AwaitSwapRequestBehaviour awaitSwapRequest = new AwaitSwapRequestBehaviour(); // Gets the student's response
										requestActivity.addSubBehaviour(awaitSwapRequest);
										if (awaitSwapRequest.onEnd() == 1) {
											slotsToSwitch.add(swapRequest);
											break;
										}
									}
								}
							}
							
							System.out.println("Slots to switch size is " + slotsToSwitch.size());
							
							// Null pointer if no slots to switch
							if (slotsToSwitch.size() > 0) {
								SequentialBehaviour requestSlots = new SequentialBehaviour();
								requestSlots.addSubBehaviour(new InitiateSwapConfirmBehaviour(slotsToSwitch));
								requestSlots.addSubBehaviour(new AwaitSwapConfirmBehaviour());
							}
						}
						else {
							System.out.println("Messageboard is empty");
						}
						
						System.out.println("NEXT TO SEND UNHAPPYSLOT"); // ISN'T BEING SENT A MESSAGE FOR THIS?
						addBehaviour(new SendUnhappySlot());
					}
				}
				catch(Exception e) {
					e.printStackTrace();
				}
			}
			else {
				block();
			}
		}
	}
	
	
	// Initiates SwapFinal request to another StudentAgent
	public class InitiateSwapRequestBehaviour extends OneShotBehaviour {
		private SwapFinal swapRequest;
		
		public InitiateSwapRequestBehaviour(SwapFinal swapRequest) {
			this.swapRequest = swapRequest;
		}
		
		@Override
		public void action() {
			System.out.println("STUDENT InitiateSwapRequestBehaviour");
			ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);
			msg.setLanguage(codec.getName());
			msg.setOntology(ontology.getName());
			msg.addReceiver(swapRequest.getInitalSwapRequest().getAgentFrom());
			msg.setConversationId("swapRequest"); // swapRequest from student.. swapConfirm from timetable
			
			Action request = new Action();
			request.setAction(swapRequest);
			request.setActor(myAgent.getAID());
			
			try {
				getContentManager().fillContent(msg, request);
				send(msg);
			}
			catch(CodecException codecE) {
				codecE.printStackTrace();
			}
			catch(OntologyException oe) {
				oe.printStackTrace();
			}
		}
	}
	
	// Waits for a SwapFinal response from a StudentAgent
	public class AwaitSwapRequestBehaviour extends Behaviour {
		private boolean responseReceived = false; // POSSIBLY RESEND NEW REQUEST IF NOT FILLED IN TIME?
		private int positiveResponse = 0;
		
		@Override
		public void action() {
			MessageTemplate mt = MessageTemplate.MatchConversationId("swapRequest");
			ACLMessage msg = myAgent.receive(mt); 
			if (msg != null) {
				System.out.println("STUDENT AwaitSwapRequestBehaviour");
				try {
					ContentElement ce = getContentManager().extractContent(msg);
					if (ce instanceof Action) {
						Concept action = ((Action)ce).getAction();
						if (action instanceof SwapFinal) {
							if (msg.getPerformative() == ACLMessage.AGREE) {
								this.positiveResponse = 1;
							}else if (msg.getPerformative() == ACLMessage.REFUSE) {
								this.positiveResponse = 0;
							}
						}
					}
				}
				catch (CodecException ce) {
					ce.printStackTrace();
				}
				catch (OntologyException oe) {
					oe.printStackTrace();
				}
			}
			else {
				block();
			}
		}
		
		// Return 1 if StudentAgent agrees swap, else return 0
		public int onEnd() {
			return positiveResponse;
		}

		@Override
		public boolean done() {
			return responseReceived;
		}
	}
	
	// Initiates SwapFinal request of slots to the TimetablingAgent
	public class InitiateSwapConfirmBehaviour extends OneShotBehaviour {
		private SlotsRequested swapRequests;
		
		public InitiateSwapConfirmBehaviour(ArrayList<SwapFinal> slotsToSwitch) {
			this.swapRequests.setSlots(slotsToSwitch);
		}
		
		@Override
		public void action() {
			System.out.println("STUDENT InitiateSwapConfirmBehaviour");
			ACLMessage msg = new ACLMessage(ACLMessage.REQUEST);
			msg.setLanguage(codec.getName());
			msg.setOntology(ontology.getName());
			msg.addReceiver(timetableAgent);
			msg.setConversationId("swapConfirm"); // swapRequest from student.. swapConfirm from timetable
			
			try {
				getContentManager().fillContent(msg, swapRequests); // slotsRequested is a predicate
				send(msg);
			}
			catch(CodecException codecE) {
				codecE.printStackTrace();
			}
			catch(OntologyException oe) {
				oe.printStackTrace();
			}
		}
	}
	
	// Awaits the SwapFinal update from the TimetablingAgent
	public class AwaitSwapConfirmBehaviour extends Behaviour {
		boolean receivedReply = false;
		int response = 0;
		
		@Override
		public void action() {
			System.out.println("STUDENT AwaitSwapConfirmBehaviour");
			MessageTemplate mt = MessageTemplate.MatchConversationId("swapConfirm");
			ACLMessage msg = myAgent.receive(mt); 
			if (msg != null) {
				try {
					ContentElement ce = getContentManager().extractContent(msg);
					if (ce instanceof SlotsRequested) {
						Concept action = ((Action)ce).getAction();
						if (action instanceof SwapFinal) {
							if (msg.getPerformative() == ACLMessage.AGREE) {
								this.response = 1;
							}else if (msg.getPerformative() == ACLMessage.REFUSE) {
								this.response = 0;
							}
						}
					}
				}
				catch (CodecException ce) {
					ce.printStackTrace();
				}
				catch (OntologyException oe) {
					oe.printStackTrace();
				}
			}
			else {
				block();
			}
		}

		@Override
		public boolean done() {
			return receivedReply;
		}
		
		@Override
		public int onEnd() {
			return response;
		}
	}
	
	// Responds to the SwapFinal request of another StudentAgent & of the TimetableAgent -- Can be re-used since just yes/no
	public class ExamineSwapRequestBehaviour extends CyclicBehaviour {
		@Override
		public void action() {
			MessageTemplate mt = MessageTemplate.or(MessageTemplate.MatchConversationId("swapRequest"), MessageTemplate.MatchConversationId("swapRequestFinal"));
			ACLMessage msg = myAgent.receive(mt); 
			if (msg != null) {
				try {
					System.out.println("STUDENT ExamineSwapRequestBehaviour");
					ContentElement ce = getContentManager().extractContent(msg);
					if (ce instanceof SwapFinal) {
						SwapFinal swapRequest = (SwapFinal) ce;
						SwapInitial swapInitial = swapRequest.getInitalSwapRequest();
						
						ACLMessage reply = msg.createReply();
						getContentManager().fillContent(reply, swapRequest);
						
						int count = 0;
						for (TutorialGroup tutorial : CurrentTutorials) {
							if (!tutorial.getTutorialID().equals(swapInitial.getTutorial().getTutorialID())) { // IF THE SAME TUTORIAL
								if (SlotFitness(tutorial.getTimeslot()) < SlotFitness(swapInitial.getTutorial().getTimeslot())) {
									reply.setPerformative(ACLMessage.AGREE);
									if (msg.getConversationId() == "swapRequestFinal") {
										CurrentTutorials[count] = swapInitial.getTutorial();
									}
									break;
								}
								else {
									reply.setPerformative(ACLMessage.REFUSE);
									break;
								}
							}
							count++;
						}
						send(reply);
					}
				}
				catch (CodecException ce) {
					ce.printStackTrace();
				}
				catch (OntologyException oe) {
					oe.printStackTrace();
				}
			}
			else {
				block();
			}
		}
	}
	
	// Sends worst slot to Timetable Agent OR check AGENT IS HAPPY HERE
	public class SendUnhappySlot extends Behaviour {
		private boolean isDone = false;
		
		@Override
		public void action() {
			System.out.println("SENDING UNHAPPY SLOT");
			MessageTemplate mt = MessageTemplate.MatchConversationId("slotRequest");
			ACLMessage msg = myAgent.receive(mt); 
			if (msg != null) {
				System.out.println("STUDENT SendUnhappySlot");
				try {
					ContentElement ce = getContentManager().extractContent(msg);
					if (ce instanceof Action) {
						Concept action = ((Action)ce).getAction();
						if (action instanceof UnhappySlot) {
							
							double meanHappiness = 0;
							
							// Get Mean unhappiness across slots
							for (int i = 0; i < CurrentTutorials.length; i++) {
								meanHappiness += SlotFitness(CurrentTutorials[i].getTimeslot());
							}
							meanHappiness /= CurrentTutorials.length;
							
							// If happy enough with slots
							if (meanHappiness < 0.5) {
								
								int worstTutorial = 0;
								
								for (int i = 0; i < CurrentTutorials.length; i++) {
									if (SlotFitness(CurrentTutorials[i].getTimeslot()) < SlotFitness(CurrentTutorials[worstTutorial].getTimeslot())) {
										worstTutorial = i;
									}
								} // Pass to TimetablingAgent and check it's not on MessageBoard already
								
								UnhappySlot slot = new UnhappySlot();
								
								SwapInitial si = new SwapInitial();
								si.setAgentFrom(myAgent.getAID());
								si.setTutorial(CurrentTutorials[worstTutorial]);
								slot.setSlotToSwap(si);
								
								Action newAction = new Action();
								newAction.setActor(getAID());
								newAction.setAction(slot);
								
								ACLMessage reply = msg.createReply();
								
								try {
									getContentManager().fillContent(reply, newAction);
									send(reply);
								}
								catch(CodecException codecE) {
									codecE.printStackTrace();
								}
								catch(OntologyException oe) {
									oe.printStackTrace();
								}
							}else {
								
								ACLMessage reply = msg.createReply();
								
								PleasedWith pleased = new PleasedWith();
								pleased.setStudent(getAID());
								
								try {
									getContentManager().fillContent(reply, pleased);
									send(reply);
								}
								catch(CodecException codecE) {
									codecE.printStackTrace();
								}
								catch(OntologyException oe) {
									oe.printStackTrace();
								}
								
							}
						}
					}
				}
				catch (CodecException ce) {
					ce.printStackTrace();
				}
				catch (OntologyException oe) {
					oe.printStackTrace();
				}
			}
			else {
				block();
			}
		}

		@Override
		public boolean done() {
			return isDone;
		}
		
	}
	
	// COULD DO HAPPINESS AS A %? DO MEAN HAPPINESS?
	
	// Returns the fitness of any time slot for the agent
	private double SlotFitness(Timeslot slot) {
		System.out.println("Slot time is " + slot.getTime() + " and slot date is " + slot.getDay());
		return 1 / (SlotPreferences[slot.getDay()][slot.getTime()] + 1);
	}
	
	// Register with the DFD
	protected void register() {
		DFAgentDescription dfd = new DFAgentDescription ();
		dfd.setName(getAID());
		
		ServiceDescription sd = new ServiceDescription();
		sd.setType("student-agent");
		sd.setName( getLocalName() + "-student-agent");
		dfd.addServices(sd);
		
		try{
			DFService.register(this , dfd);
		}
		catch(FIPAException e) {
			e.printStackTrace();
		}
	}
}
